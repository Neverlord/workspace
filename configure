#!/usr/bin/env python

# Usage example: ./configure --caf:with-log-level=trace --all:enable-asan

import sys, re, os, shutil

from subprocess import call
from subprocess import check_call

# list dependencies
deps = {
  'benchmarks': ['caf'],
  'broker': ['caf'],
  'core': ['vast', 'caf', 'broker'],
  'vast': ['caf'],
}

# dev mode flags
dev_mode_flags = {
  'benchmarks': [],
  'broker': ['--build-type=debug', '--enable-asan', '--enable-debug'],
  'caf': ['--dev-mode'],
  'core': ['--dev-mode'],
  'vast': ['--dev-mode'],
}

# get current workspace directory
workspace = os.path.dirname(os.path.realpath(__file__))

# configures whether we run in test mode
dry_run = False

# configures whether we delete existing build directories
clean_slate = False

# turn on developer mode for given project
def dev_mode(project, options):
  for opt in dev_mode_flags[project]:
    options.append(opt)

# invokes ./configure script of the project
def config_project(project, settings, options):
  cli = options[project]
  path = os.path.join(workspace, project)
  print('>>> chdir: ' + path)
  os.chdir(path)
  build_dir = settings['path']
  if os.path.isdir(build_dir):
    print('>>> remove outdated build directory: ' + build_dir)
    if clean_slate and not dry_run:
      shutil.rmtree(build_dir)
  cmd = ["./configure", "--build-dir=" + build_dir]
  cmd.extend(cli)
  print('>>> call: ' + ' '.join(cmd))
  if not dry_run:
    check_call(cmd)
  os.chdir(workspace)

# builds the project via ninja
def build_project(project, settings):
  path = os.path.join(workspace, project)
  os.chdir(path)
  cmd = ["ninja", "-C", settings['path']]
  print('>>> call: ' + str(cmd))
  if not dry_run:
    check_call(cmd)
  os.chdir(workspace)

def is_hidden(file_name):
  return name.startswith('.')

def is_cmake_project(dir_name):
  return os.path.isdir(dir_name) and not is_hidden(dir_name) and os.path.isfile(dir_name + '/CMakeLists.txt')

def process_project(name, state, xs, options, as_depdency):
  print('>>> process ' + name)
  # build dependencies first
  if name in deps:
    for dep in deps[name]:
      print('>>> resolve depdency of ' + name + ': ' + dep)
      process_project(dep, xs[dep], xs, options, True)
      options[name].append('--with-' + dep + '=' + xs[dep]['path'])
  if not state['configured']:
    print('>>> configure ' + name)
    config_project(name, xs[name], options)
    state['configured'] = True
  if as_depdency and not state['build']:
    print('>>> build ' + name)
    build_project(name, xs[name])
    state['build'] = True

def process_projects(xs, options):
  for name, settings in xs.items():
    process_project(name, settings, xs, options, False)


if __name__ == "__main__":
  options = {}
  # first iterate all subdirectories (= projects) and add dictionary entries
  # for each of them
  for name in os.listdir(workspace):
    if is_cmake_project(name):
      options[name] = ["--generator=Ninja"]
  # our default pattern extracts the project name (group 1) and
  # project-specific options (group 2)
  pattern = re.compile("--([a-z]+):(.+)")
  # setting the build type affects all projects
  build_type_pattern = re.compile("--build-type=(.+)")
  # build debug by default
  build_type = "debug"
  # parse CLI arguments
  for arg in sys.argv[1:]:
    rxres = pattern.match(arg)
    if arg == '--dev-mode':
      for key in options:
        dev_mode(key, options[key])
    elif arg == '--dry-run':
      dry_run = True
    elif arg == 'delete-old-builds':
      clean_slate = True
    elif rxres != None:
      project = rxres.group(1)
      opt = "--" + rxres.group(2)
      # add options prefixed with '--all:...' to all projects
      if project == "all":
        for key in options:
          options[key].append(opt)
      else:
        options[project].append(opt)
    else:
      rxres = build_type_pattern.match(arg)
      if rxres != None:
        build_type = rxres.group(1)
        for key in options:
          options[key].append(arg)
  # scan workspace for loaded projects
  projs = {}
  for name in os.listdir(workspace):
    abs_path = os.path.join(workspace, name)
    if is_cmake_project(name):
      projs[name] = {
        'path': abs_path + '/build/' + build_type,
        'build': False,
        'configured': False,
      }
  # configure/build recursively
  process_projects(projs, options)
