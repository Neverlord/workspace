#!/usr/bin/env python

import sys, os, json

from collections import OrderedDict

# get current workspace directory
workspace = os.path.dirname(os.path.realpath(__file__))

# fetch the dependencies from the settings file
settings = json.load(open(workspace + '/settings.json'))
deps = settings['dependencies']

# constants
build_types = ['debug', 'release', 'RelWithDebInfo']

def resolve_dependencies(name):
  # build dependency list
  result = []
  for dep in deps.get(name, []):
    result.extend(resolve_dependencies(dep))
  # de-duplicate dependencies
  return list(dict.fromkeys(result + [name]))

def main():
  # verify build type
  build_type = sys.argv[1]
  if (not build_type in build_types):
    print('>>> invalid build type, expected one of: ' + str(build_types))
    return
  # convenience variables
  buildSuffix = '/build/' + build_type
  cleanSuffix = '/build/' + build_type + ' clean'
  dbSuffix = buildSuffix + '/compile_commands.json'
  # compute full build order including dependencies
  build_order = resolve_dependencies(sys.argv[2])
  # write workspaces Makefile
  with open('Makefile', 'w') as f:
    f.write('all:\n\t')
    f.write(' && '.join('ninja -C ' + x + buildSuffix for x in build_order))
    f.write('\nclean:\n\t')
    f.write(' && '.join('ninja -C ' + x + cleanSuffix for x in build_order))
    f.write('\n')
  # write localMakefiles
  for proj in build_order:
    with open(proj + '/Makefile', 'w') as f:
      f.write('all:\n\t')
      f.write('ninja -C build/' + build_type)
      f.write('\nclean:\n\t')
      f.write('ninja -C build/' + build_type + ' clean')
      f.write('\n')
  # read all compile databases into a single one
  db = []
  for lst in (json.load(open(x + dbSuffix)) for x in build_order):
    db.extend(lst)
  json.dump(db, open(workspace + '/compile_commands.json', 'w'), indent = 2)

if __name__ == "__main__":
  main()
